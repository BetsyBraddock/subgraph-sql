{"version":3,"file":"Formatter.js","names":["Formatter","cfg","params","Params","Error","cls","constructor","cachedTokenizer","tokenizer","query","tokens","tokenize","processedTokens","AliasAs","process","ast","Parser","parse","formattedQuery","formatAst","finalQuery","postFormat","trimEnd","statements","map","stat","formatStatement","join","repeat","linesBetweenQueries","statement","layout","ExpressionFormatter","Layout","Indentation","indentString","format","children","hasSemicolon","newlineBeforeSemicolon","add","WS","NEWLINE","NO_SPACE","toString","tabulateAlias","formatAliasPositions","commaPosition","formatCommaPositions"],"sources":["../../src/formatter/Formatter.ts"],"sourcesContent":["import type { FormatOptions } from 'src/types';\nimport { indentString } from 'src/formatter/config';\nimport Params from 'src/formatter/Params';\nimport Tokenizer from 'src/lexer/Tokenizer';\n\nimport Parser from 'src/parser/Parser';\nimport { Statement } from 'src/parser/ast';\n\nimport formatCommaPositions from './formatCommaPositions';\nimport formatAliasPositions from './formatAliasPositions';\nimport ExpressionFormatter from './ExpressionFormatter';\nimport AliasAs from './AliasAs';\nimport Layout, { WS } from './Layout';\nimport Indentation from './Indentation';\n\n/** Main formatter class that produces a final output string from list of tokens */\nexport default class Formatter {\n  private cfg: FormatOptions;\n  private params: Params;\n\n  constructor(cfg: FormatOptions) {\n    this.cfg = cfg;\n    this.params = new Params(this.cfg.params);\n  }\n\n  /**\n   * SQL Tokenizer for this formatter, provided by subclasses.\n   */\n  protected tokenizer(): Tokenizer {\n    throw new Error('tokenizer() not implemented by subclass');\n  }\n\n  // Cache the tokenizer for each class (each SQL dialect)\n  // So we wouldn't need to recreate the tokenizer, which is kinda expensive,\n  // for each call to format() function.\n  private cachedTokenizer(): Tokenizer {\n    const cls: Function & { cachedTokenizer?: Tokenizer } = this.constructor;\n    if (!cls.cachedTokenizer) {\n      cls.cachedTokenizer = this.tokenizer();\n    }\n    return cls.cachedTokenizer;\n  }\n\n  /**\n   * Formats an SQL query.\n   * @param {string} query - The SQL query string to be formatted\n   * @return {string} The formatter query\n   */\n  public format(query: string): string {\n    const tokens = this.cachedTokenizer().tokenize(query);\n    const processedTokens = new AliasAs(this.cfg, tokens).process();\n    const ast = new Parser(processedTokens).parse();\n    const formattedQuery = this.formatAst(ast);\n    const finalQuery = this.postFormat(formattedQuery);\n\n    return finalQuery.trimEnd();\n  }\n\n  private formatAst(statements: Statement[]): string {\n    return statements\n      .map(stat => this.formatStatement(stat))\n      .join('\\n'.repeat(this.cfg.linesBetweenQueries + 1));\n  }\n\n  private formatStatement(statement: Statement): string {\n    const layout = new ExpressionFormatter({\n      cfg: this.cfg,\n      params: this.params,\n      layout: new Layout(new Indentation(indentString(this.cfg))),\n    }).format(statement.children);\n\n    if (!statement.hasSemicolon) {\n      // do nothing\n    } else if (this.cfg.newlineBeforeSemicolon) {\n      layout.add(WS.NEWLINE, ';');\n    } else {\n      layout.add(WS.NO_SPACE, ';');\n    }\n    return layout.toString();\n  }\n\n  private postFormat(query: string): string {\n    if (this.cfg.tabulateAlias) {\n      query = formatAliasPositions(query);\n    }\n    if (this.cfg.commaPosition === 'before' || this.cfg.commaPosition === 'tabular') {\n      query = formatCommaPositions(query, this.cfg.commaPosition, indentString(this.cfg));\n    }\n\n    return query;\n  }\n}\n"],"mappings":"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"}