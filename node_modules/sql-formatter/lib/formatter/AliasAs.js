"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token = require("../lexer/token");

var _AsTokenFactory = _interopRequireDefault(require("./AsTokenFactory"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Adds and removes AS tokens as configured by aliasAs option */
var AliasAs = /*#__PURE__*/function () {
  function AliasAs(cfg, tokens) {
    _classCallCheck(this, AliasAs);

    _defineProperty(this, "index", 0);

    _defineProperty(this, "tokens", []);

    _defineProperty(this, "previousReservedToken", _token.EOF_TOKEN);

    _defineProperty(this, "previousCommandToken", _token.EOF_TOKEN);

    _defineProperty(this, "asTokenFactory", void 0);

    _defineProperty(this, "aliasAs", void 0);

    this.aliasAs = cfg.aliasAs;
    this.asTokenFactory = new _AsTokenFactory["default"](cfg.keywordCase, tokens);
    this.tokens = tokens;
  }
  /** Returns tokens with AS tokens added/removed as needed */


  _createClass(AliasAs, [{
    key: "process",
    value: function process() {
      var processedTokens = [];

      for (this.index = 0; this.index < this.tokens.length; this.index++) {
        var token = this.tokens[this.index];

        if ((0, _token.isReserved)(token)) {
          this.previousReservedToken = token;

          if (token.type === _token.TokenType.RESERVED_COMMAND) {
            this.previousCommandToken = token;
          }
        }

        if (_token.isToken.AS(token)) {
          if (!this.shouldRemove()) {
            processedTokens.push(token);
          }
        } else if (token.type === _token.TokenType.IDENTIFIER || token.type === _token.TokenType.NUMBER || token.type === _token.TokenType.STRING || token.type === _token.TokenType.VARIABLE) {
          if (this.shouldAddBefore(token)) {
            processedTokens.push(this.asTokenFactory.token());
          }

          processedTokens.push(token);

          if (this.shouldAddAfter()) {
            processedTokens.push(this.asTokenFactory.token());
          }
        } else {
          processedTokens.push(token);
        }
      }

      return processedTokens;
    }
    /** True when AS keyword should be added *before* current token */

  }, {
    key: "shouldAddBefore",
    value: function shouldAddBefore(token) {
      return this.isMissingTableAlias(token) || this.isMissingSelectColumnAlias(token);
    } // if table alias is missing and should be added

  }, {
    key: "isMissingTableAlias",
    value: function isMissingTableAlias(token) {
      return this.aliasAs === 'always' && token.type === _token.TokenType.IDENTIFIER && this.lookBehind().value === ')';
    } // if select column alias is missing and should be added

  }, {
    key: "isMissingSelectColumnAlias",
    value: function isMissingSelectColumnAlias(token) {
      var prevToken = this.lookBehind();
      var nextToken = this.lookAhead();
      return (this.aliasAs === 'always' || this.aliasAs === 'select') && this.isWithinSelect() && token.type === _token.TokenType.IDENTIFIER && (_token.isToken.END(prevToken) || (prevToken.type === _token.TokenType.IDENTIFIER || prevToken.type === _token.TokenType.NUMBER) && (nextToken.type === _token.TokenType.COMMA || (0, _token.isCommand)(nextToken)));
    }
    /** True when AS keyword should be added *after* current token */

  }, {
    key: "shouldAddAfter",
    value: function shouldAddAfter() {
      return this.isEdgeCaseCTE() || this.isEdgeCaseCreateTable() || this.isMissingTypeCastAs();
    } // checks for CAST(«expression» [AS] type)

  }, {
    key: "isMissingTypeCastAs",
    value: function isMissingTypeCastAs() {
      return this.aliasAs === 'never' && this.isWithinSelect() && _token.isToken.CAST(this.getPreviousReservedToken()) && _token.isToken.AS(this.lookAhead()) && (this.lookAhead(2).type === _token.TokenType.IDENTIFIER || this.lookAhead(2).type === _token.TokenType.RESERVED_KEYWORD) && this.lookAhead(3).value === ')';
    } // checks for WITH `table` [AS] (

  }, {
    key: "isEdgeCaseCTE",
    value: function isEdgeCaseCTE() {
      var nextToken = this.lookAhead();
      return this.aliasAs === 'never' && _token.isToken.WITH(this.lookBehind()) && (nextToken.value === '(' || _token.isToken.AS(nextToken) && this.lookAhead(2).value === '(');
    } // checks for CREATE TABLE `table` [AS] WITH (

  }, {
    key: "isEdgeCaseCreateTable",
    value: function isEdgeCaseCreateTable() {
      var prevToken = this.lookBehind();
      var nextToken = this.lookAhead();
      return this.aliasAs === 'never' && (_token.isToken.TABLE(prevToken) || prevToken.value.endsWith('TABLE')) && (_token.isToken.WITH(nextToken) || _token.isToken.AS(nextToken) && _token.isToken.WITH(this.lookAhead(2)));
    }
    /* True when the current AS token should be discarded */

  }, {
    key: "shouldRemove",
    value: function shouldRemove() {
      return this.aliasAs === 'never' || this.aliasAs === 'select' && this.isRemovableNonSelectAs();
    }
  }, {
    key: "isRemovableNonSelectAs",
    value: function isRemovableNonSelectAs() {
      return this.lookBehind().value === ')' && // ) [AS] alias but not SELECT (a) [AS] alpha
      !this.isWithinSelect() && this.lookAhead().value !== '(' // skip WITH foo [AS] ( ...
      ;
    }
  }, {
    key: "getPreviousReservedToken",
    value: function getPreviousReservedToken() {
      return this.previousReservedToken;
    }
  }, {
    key: "isWithinSelect",
    value: function isWithinSelect() {
      return _token.isToken.SELECT(this.previousCommandToken);
    }
  }, {
    key: "lookBehind",
    value: function lookBehind() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.lookAhead(-n);
    }
  }, {
    key: "lookAhead",
    value: function lookAhead() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.tokens[this.index + n] || _token.EOF_TOKEN;
    }
  }]);

  return AliasAs;
}();

exports["default"] = AliasAs;
module.exports = exports.default;
//# sourceMappingURL=AliasAs.js.map