{"version":3,"file":"Parser.js","names":["Parser","tokens","statements","stat","statement","push","children","look","type","TokenType","DELIMITER","next","NodeType","hasSemicolon","EOF","length","undefined","expression","limitClause","clause","binaryClause","functionCall","arraySubscript","parenthesis","betweenPredicate","allColumnsAsterisk","nextTokenNode","RESERVED_COMMAND","name","expressionsUntilClauseEnd","nameToken","RESERVED_BINARY_COMMAND","binary_clause","RESERVED_KEYWORD","IDENTIFIER","value","whitespaceBefore","function_call","array_subscript","arrayToken","OPEN_PAREN","token","openParen","closeParen","CLOSE_PAREN","isToken","BETWEEN","AND","between_predicate","betweenToken","expr1","andToken","expr2","LIMIT","limitToken","t","COMMA","limit_clause","offset","count","SELECT","all_columns_asterisk","extraPredicate","ahead","index","EOF_TOKEN"],"sources":["../../src/parser/Parser.ts"],"sourcesContent":["/* eslint-disable no-cond-assign */\nimport { EOF_TOKEN, type Token, TokenType, isToken } from 'src/lexer/token';\nimport {\n  AllColumnsAsterisk,\n  ArraySubscript,\n  AstNode,\n  BetweenPredicate,\n  BinaryClause,\n  Clause,\n  FunctionCall,\n  LimitClause,\n  NodeType,\n  Parenthesis,\n  Statement,\n  TokenNode,\n} from './ast';\n\n/**\n * A simple parser that creates a very rudimentary syntax tree.\n */\nexport default class Parser {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  public parse(): Statement[] {\n    const statements: Statement[] = [];\n    let stat: Statement | undefined;\n    while ((stat = this.statement())) {\n      statements.push(stat);\n    }\n    return statements;\n  }\n\n  private statement(): Statement | undefined {\n    const children: AstNode[] = [];\n    while (true) {\n      if (this.look().type === TokenType.DELIMITER) {\n        this.next();\n        return { type: NodeType.statement, children, hasSemicolon: true };\n      } else if (this.look().type === TokenType.EOF) {\n        if (children.length > 0) {\n          return { type: NodeType.statement, children, hasSemicolon: false };\n        } else {\n          return undefined;\n        }\n      } else {\n        children.push(this.expression());\n      }\n    }\n  }\n\n  private expression(): AstNode {\n    return (\n      this.limitClause() ||\n      this.clause() ||\n      this.binaryClause() ||\n      this.functionCall() ||\n      this.arraySubscript() ||\n      this.parenthesis() ||\n      this.betweenPredicate() ||\n      this.allColumnsAsterisk() ||\n      this.nextTokenNode()\n    );\n  }\n\n  private clause(): Clause | undefined {\n    if (this.look().type === TokenType.RESERVED_COMMAND) {\n      const name = this.next();\n      const children = this.expressionsUntilClauseEnd();\n      return { type: NodeType.clause, nameToken: name, children };\n    }\n    return undefined;\n  }\n\n  private binaryClause(): BinaryClause | undefined {\n    if (this.look().type === TokenType.RESERVED_BINARY_COMMAND) {\n      const name = this.next();\n      const children = this.expressionsUntilClauseEnd();\n      return { type: NodeType.binary_clause, nameToken: name, children };\n    }\n    return undefined;\n  }\n\n  private functionCall(): FunctionCall | undefined {\n    if (\n      (this.look().type === TokenType.RESERVED_KEYWORD ||\n        this.look().type === TokenType.IDENTIFIER) &&\n      this.look(1).value === '(' &&\n      !this.look(1).whitespaceBefore\n    ) {\n      return {\n        type: NodeType.function_call,\n        nameToken: this.next(),\n        parenthesis: this.parenthesis() as Parenthesis,\n      };\n    }\n    return undefined;\n  }\n\n  private arraySubscript(): ArraySubscript | undefined {\n    if (\n      (this.look().type === TokenType.RESERVED_KEYWORD ||\n        this.look().type === TokenType.IDENTIFIER) &&\n      this.look(1).value === '['\n    ) {\n      return {\n        type: NodeType.array_subscript,\n        arrayToken: this.next(),\n        parenthesis: this.parenthesis() as Parenthesis,\n      };\n    }\n    return undefined;\n  }\n\n  private parenthesis(): Parenthesis | undefined {\n    if (this.look().type === TokenType.OPEN_PAREN) {\n      const children: AstNode[] = [];\n      const token = this.next();\n      const openParen = token.value;\n      let closeParen = '';\n      while (this.look().type !== TokenType.CLOSE_PAREN && this.look().type !== TokenType.EOF) {\n        children.push(this.expression());\n      }\n      if (this.look().type === TokenType.CLOSE_PAREN) {\n        closeParen = this.next().value;\n      }\n      return { type: NodeType.parenthesis, children, openParen, closeParen };\n    }\n    return undefined;\n  }\n\n  private betweenPredicate(): BetweenPredicate | undefined {\n    if (isToken.BETWEEN(this.look()) && isToken.AND(this.look(2))) {\n      return {\n        type: NodeType.between_predicate,\n        betweenToken: this.next(),\n        expr1: this.next(),\n        andToken: this.next(),\n        expr2: this.next(),\n      };\n    }\n    return undefined;\n  }\n\n  private limitClause(): LimitClause | undefined {\n    if (isToken.LIMIT(this.look())) {\n      const limitToken = this.next();\n      const expr1 = this.expressionsUntilClauseEnd(t => t.type === TokenType.COMMA);\n      if (this.look().type === TokenType.COMMA) {\n        this.next(); // Discard comma token\n        const expr2 = this.expressionsUntilClauseEnd();\n        return {\n          type: NodeType.limit_clause,\n          limitToken,\n          offset: expr1,\n          count: expr2,\n        };\n      } else {\n        return {\n          type: NodeType.limit_clause,\n          limitToken,\n          count: expr1,\n        };\n      }\n    }\n    return undefined;\n  }\n\n  private allColumnsAsterisk(): AllColumnsAsterisk | undefined {\n    if (this.look().value === '*' && isToken.SELECT(this.look(-1))) {\n      this.next();\n      return { type: NodeType.all_columns_asterisk };\n    }\n    return undefined;\n  }\n\n  private expressionsUntilClauseEnd(\n    extraPredicate: (token: Token) => boolean = () => false\n  ): AstNode[] {\n    const children: AstNode[] = [];\n    while (\n      this.look().type !== TokenType.RESERVED_COMMAND &&\n      this.look().type !== TokenType.RESERVED_BINARY_COMMAND &&\n      this.look().type !== TokenType.EOF &&\n      this.look().type !== TokenType.CLOSE_PAREN &&\n      this.look().type !== TokenType.DELIMITER &&\n      !extraPredicate(this.look())\n    ) {\n      children.push(this.expression());\n    }\n    return children;\n  }\n\n  // Returns current token without advancing the pointer\n  private look(ahead = 0): Token {\n    return this.tokens[this.index + ahead] || EOF_TOKEN;\n  }\n\n  // Returns current token and advances the pointer to next token\n  private next(): Token {\n    return this.tokens[this.index++] || EOF_TOKEN;\n  }\n\n  private nextTokenNode(): TokenNode {\n    return { type: NodeType.token, token: this.next() };\n  }\n}\n"],"mappings":"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"}