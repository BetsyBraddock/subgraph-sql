"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token2 = require("../lexer/token");

var _ast = require("./ast");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A simple parser that creates a very rudimentary syntax tree.
 */
var Parser = /*#__PURE__*/function () {
  function Parser(tokens) {
    _classCallCheck(this, Parser);

    this.tokens = tokens;

    _defineProperty(this, "index", 0);
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse() {
      var statements = [];
      var stat;

      while (stat = this.statement()) {
        statements.push(stat);
      }

      return statements;
    }
  }, {
    key: "statement",
    value: function statement() {
      var children = [];

      while (true) {
        if (this.look().type === _token2.TokenType.DELIMITER) {
          this.next();
          return {
            type: _ast.NodeType.statement,
            children: children,
            hasSemicolon: true
          };
        } else if (this.look().type === _token2.TokenType.EOF) {
          if (children.length > 0) {
            return {
              type: _ast.NodeType.statement,
              children: children,
              hasSemicolon: false
            };
          } else {
            return undefined;
          }
        } else {
          children.push(this.expression());
        }
      }
    }
  }, {
    key: "expression",
    value: function expression() {
      return this.limitClause() || this.clause() || this.binaryClause() || this.functionCall() || this.arraySubscript() || this.parenthesis() || this.betweenPredicate() || this.allColumnsAsterisk() || this.nextTokenNode();
    }
  }, {
    key: "clause",
    value: function clause() {
      if (this.look().type === _token2.TokenType.RESERVED_COMMAND) {
        var name = this.next();
        var children = this.expressionsUntilClauseEnd();
        return {
          type: _ast.NodeType.clause,
          nameToken: name,
          children: children
        };
      }

      return undefined;
    }
  }, {
    key: "binaryClause",
    value: function binaryClause() {
      if (this.look().type === _token2.TokenType.RESERVED_BINARY_COMMAND) {
        var name = this.next();
        var children = this.expressionsUntilClauseEnd();
        return {
          type: _ast.NodeType.binary_clause,
          nameToken: name,
          children: children
        };
      }

      return undefined;
    }
  }, {
    key: "functionCall",
    value: function functionCall() {
      if ((this.look().type === _token2.TokenType.RESERVED_KEYWORD || this.look().type === _token2.TokenType.IDENTIFIER) && this.look(1).value === '(' && !this.look(1).whitespaceBefore) {
        return {
          type: _ast.NodeType.function_call,
          nameToken: this.next(),
          parenthesis: this.parenthesis()
        };
      }

      return undefined;
    }
  }, {
    key: "arraySubscript",
    value: function arraySubscript() {
      if ((this.look().type === _token2.TokenType.RESERVED_KEYWORD || this.look().type === _token2.TokenType.IDENTIFIER) && this.look(1).value === '[') {
        return {
          type: _ast.NodeType.array_subscript,
          arrayToken: this.next(),
          parenthesis: this.parenthesis()
        };
      }

      return undefined;
    }
  }, {
    key: "parenthesis",
    value: function parenthesis() {
      if (this.look().type === _token2.TokenType.OPEN_PAREN) {
        var children = [];

        var _token = this.next();

        var openParen = _token.value;
        var closeParen = '';

        while (this.look().type !== _token2.TokenType.CLOSE_PAREN && this.look().type !== _token2.TokenType.EOF) {
          children.push(this.expression());
        }

        if (this.look().type === _token2.TokenType.CLOSE_PAREN) {
          closeParen = this.next().value;
        }

        return {
          type: _ast.NodeType.parenthesis,
          children: children,
          openParen: openParen,
          closeParen: closeParen
        };
      }

      return undefined;
    }
  }, {
    key: "betweenPredicate",
    value: function betweenPredicate() {
      if (_token2.isToken.BETWEEN(this.look()) && _token2.isToken.AND(this.look(2))) {
        return {
          type: _ast.NodeType.between_predicate,
          betweenToken: this.next(),
          expr1: this.next(),
          andToken: this.next(),
          expr2: this.next()
        };
      }

      return undefined;
    }
  }, {
    key: "limitClause",
    value: function limitClause() {
      if (_token2.isToken.LIMIT(this.look())) {
        var limitToken = this.next();
        var expr1 = this.expressionsUntilClauseEnd(function (t) {
          return t.type === _token2.TokenType.COMMA;
        });

        if (this.look().type === _token2.TokenType.COMMA) {
          this.next(); // Discard comma token

          var expr2 = this.expressionsUntilClauseEnd();
          return {
            type: _ast.NodeType.limit_clause,
            limitToken: limitToken,
            offset: expr1,
            count: expr2
          };
        } else {
          return {
            type: _ast.NodeType.limit_clause,
            limitToken: limitToken,
            count: expr1
          };
        }
      }

      return undefined;
    }
  }, {
    key: "allColumnsAsterisk",
    value: function allColumnsAsterisk() {
      if (this.look().value === '*' && _token2.isToken.SELECT(this.look(-1))) {
        this.next();
        return {
          type: _ast.NodeType.all_columns_asterisk
        };
      }

      return undefined;
    }
  }, {
    key: "expressionsUntilClauseEnd",
    value: function expressionsUntilClauseEnd() {
      var extraPredicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
        return false;
      };
      var children = [];

      while (this.look().type !== _token2.TokenType.RESERVED_COMMAND && this.look().type !== _token2.TokenType.RESERVED_BINARY_COMMAND && this.look().type !== _token2.TokenType.EOF && this.look().type !== _token2.TokenType.CLOSE_PAREN && this.look().type !== _token2.TokenType.DELIMITER && !extraPredicate(this.look())) {
        children.push(this.expression());
      }

      return children;
    } // Returns current token without advancing the pointer

  }, {
    key: "look",
    value: function look() {
      var ahead = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.tokens[this.index + ahead] || _token2.EOF_TOKEN;
    } // Returns current token and advances the pointer to next token

  }, {
    key: "next",
    value: function next() {
      return this.tokens[this.index++] || _token2.EOF_TOKEN;
    }
  }, {
    key: "nextTokenNode",
    value: function nextTokenNode() {
      return {
        type: _ast.NodeType.token,
        token: this.next()
      };
    }
  }]);

  return Parser;
}();

exports["default"] = Parser;
module.exports = exports.default;
//# sourceMappingURL=Parser.js.map