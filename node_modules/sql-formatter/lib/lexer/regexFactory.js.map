{"version":3,"file":"regexFactory.js","names":["lineComment","lineCommentTypes","RegExp","map","escapeRegExp","join","parenthesis","parens","patternToRegex","escapeParen","operator","monadOperators","polyadOperators","sortByLengthDesc","split","rejectIdentCharsPattern","rest","dashes","reservedWord","reservedKeywords","identChars","length","avoidIdentChars","reservedKeywordsPattern","toCaseInsensitivePattern","replace","parameter","paramTypes","pattern","undefined","typesRegex","quotePatterns","singleQuotePattern","quoteTypes","prefixesPattern","quote","variable","varTypes","varType","regex","stringPattern","string","identifier","specialChars","identifierPattern","first","letter","number","firstChars","restChars","withDashes"],"sources":["../../src/lexer/regexFactory.ts"],"sourcesContent":["import { sortByLengthDesc } from 'src/utils';\n\nimport type { IdentChars, QuoteType, VariableType } from './regexTypes';\nimport {\n  escapeParen,\n  escapeRegExp,\n  patternToRegex,\n  prefixesPattern,\n  toCaseInsensitivePattern,\n  withDashes,\n} from './regexUtil';\n\n/**\n * Builds a RegExp for valid line comments in a SQL dialect\n * @param {string[]} lineCommentTypes - list of character strings that denote line comments\n */\nexport const lineComment = (lineCommentTypes: string[]) =>\n  new RegExp(`(?:${lineCommentTypes.map(escapeRegExp).join('|')}).*?(?=\\r\\n|\\r|\\n|$)`, 'uy');\n\n/**\n * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`\n * @param {string[]} parens - list of strings that denote parenthesis patterns\n */\nexport const parenthesis = (parens: string[]): RegExp =>\n  patternToRegex(parens.map(escapeParen).join('|'));\n\n/**\n * Builds a RegExp containing all operators for a SQL dialect\n * @param {string} monadOperators - concatenated string of all 1-length operators\n * @param {string[]} polyadOperators - list of strings of all >1-length operators\n */\nexport const operator = (monadOperators: string, polyadOperators: string[]) =>\n  patternToRegex(\n    `${sortByLengthDesc(polyadOperators).map(escapeRegExp).join('|')}|` +\n      `[${monadOperators.split('').map(escapeRegExp).join('')}]`\n  );\n\n// Negative lookahead to avoid matching a keyword that's actually part of identifier,\n// which can happen when identifier allows word-boundary characters inside it.\n//\n// For example \"SELECT$ME\" should be tokenized as:\n// - [\"SELECT$ME\"] when $ is allowed inside identifiers\n// - [\"SELECT\", \"$\", \"ME\"] when $ can't be part of identifiers.\nconst rejectIdentCharsPattern = ({ rest, dashes }: IdentChars): string =>\n  rest || dashes ? `(?![${rest || ''}${dashes ? '-' : ''}])` : '';\n\n/**\n * Builds a RegExp for all Reserved Keywords in a SQL dialect\n */\nexport const reservedWord = (reservedKeywords: string[], identChars: IdentChars = {}): RegExp => {\n  if (reservedKeywords.length === 0) {\n    return /^\\b$/u;\n  }\n\n  const avoidIdentChars = rejectIdentCharsPattern(identChars);\n\n  const reservedKeywordsPattern = sortByLengthDesc(reservedKeywords)\n    .map(toCaseInsensitivePattern)\n    .join('|')\n    .replace(/ /gu, '\\\\s+');\n\n  return new RegExp(`(?:${reservedKeywordsPattern})${avoidIdentChars}\\\\b`, 'iuy');\n};\n\n/**\n * Builds a RegExp for parameter placeholder patterns\n * @param {string[]} paramTypes - list of strings that denote placeholder types\n * @param {string} pattern - string that denotes placeholder pattern\n */\nexport const parameter = (paramTypes: string[], pattern: string): RegExp | undefined => {\n  if (!paramTypes.length) {\n    return undefined;\n  }\n  const typesRegex = paramTypes.map(escapeRegExp).join('|');\n\n  return patternToRegex(`(?:${typesRegex})(?:${pattern})`);\n};\n\n// This enables the following quote styles:\n// 1. backtick quoted using `` to escape\n// 2. square bracket quoted (SQL Server) using ]] to escape\n// 3. double quoted using \"\" or \\\" to escape\n// 4. single quoted using '' or \\' to escape\n// 5. PostgreSQL dollar-quoted\n// 6. BigQuery '''triple-quoted'''\n// 7. BigQuery \"\"\"triple-quoted\"\"\"\n// 8. Hive and Spark variables: ${name}\nexport const quotePatterns = {\n  '``': '(?:`[^`]*(?:$|`))+',\n  '[]': '(?:\\\\[[^\\\\]]*(?:$|\\\\]))(?:\\\\][^\\\\]]*(?:$|\\\\]))*',\n  '\"\"': '(?:\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(?:\"|$))+',\n  \"''\": \"(?:'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*(?:'|$))+\",\n  '$$': '(?<tag>\\\\$\\\\w*\\\\$)[\\\\s\\\\S]*?(?:\\\\k<tag>|$)',\n  \"'''..'''\": \"'''[^\\\\\\\\]*?(?:\\\\\\\\.[^\\\\\\\\]*?)*?(?:'''|$)\",\n  '\"\"\"..\"\"\"': '\"\"\"[^\\\\\\\\]*?(?:\\\\\\\\.[^\\\\\\\\]*?)*?(?:\"\"\"|$)',\n  '{}': '(?:\\\\{[^\\\\}]*(?:$|\\\\}))',\n};\n\nconst singleQuotePattern = (quoteTypes: QuoteType): string => {\n  if (typeof quoteTypes === 'string') {\n    return quotePatterns[quoteTypes];\n  } else {\n    return prefixesPattern(quoteTypes) + quotePatterns[quoteTypes.quote];\n  }\n};\n\n/** Builds a RegExp for matching variables */\nexport const variable = (varTypes: VariableType[]): RegExp =>\n  patternToRegex(\n    varTypes\n      .map(varType => ('regex' in varType ? varType.regex : singleQuotePattern(varType)))\n      .join('|')\n  );\n\n/** Builds a quote-delimited pattern for matching all given quote types */\nexport const stringPattern = (quoteTypes: QuoteType[]): string =>\n  quoteTypes.map(singleQuotePattern).join('|');\n\n/** Builds a RegExp for matching quote-delimited patterns */\nexport const string = (quoteTypes: QuoteType[]): RegExp =>\n  patternToRegex(stringPattern(quoteTypes));\n\n/**\n * Builds a RegExp for valid identifiers in a SQL dialect\n */\nexport const identifier = (specialChars: IdentChars = {}): RegExp =>\n  patternToRegex(identifierPattern(specialChars));\n\n/**\n * Builds a RegExp string for valid identifiers in a SQL dialect\n */\nexport const identifierPattern = ({ first, rest, dashes }: IdentChars = {}): string => {\n  // Unicode letters, diacritical marks and underscore\n  const letter = '\\\\p{Alphabetic}\\\\p{Mark}_';\n  // Numbers 0..9, plus various unicode numbers\n  const number = '\\\\p{Decimal_Number}';\n\n  const firstChars = escapeRegExp(first ?? '');\n  const restChars = escapeRegExp(rest ?? '');\n\n  const pattern = `[${letter}${firstChars}][${letter}${number}${restChars}]*`;\n\n  return dashes ? withDashes(pattern) : pattern;\n};\n"],"mappings":"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"}