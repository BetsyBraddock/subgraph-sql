"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.variable = exports.stringPattern = exports.string = exports.reservedWord = exports.quotePatterns = exports.parenthesis = exports.parameter = exports.operator = exports.lineComment = exports.identifierPattern = exports.identifier = void 0;

var _utils = require("../utils");

var _regexUtil = require("./regexUtil");

/**
 * Builds a RegExp for valid line comments in a SQL dialect
 * @param {string[]} lineCommentTypes - list of character strings that denote line comments
 */
var lineComment = function lineComment(lineCommentTypes) {
  return new RegExp("(?:".concat(lineCommentTypes.map(_regexUtil.escapeRegExp).join('|'), ").*?(?=\r\n|\r|\n|$)"), 'uy');
};
/**
 * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`
 * @param {string[]} parens - list of strings that denote parenthesis patterns
 */


exports.lineComment = lineComment;

var parenthesis = function parenthesis(parens) {
  return (0, _regexUtil.patternToRegex)(parens.map(_regexUtil.escapeParen).join('|'));
};
/**
 * Builds a RegExp containing all operators for a SQL dialect
 * @param {string} monadOperators - concatenated string of all 1-length operators
 * @param {string[]} polyadOperators - list of strings of all >1-length operators
 */


exports.parenthesis = parenthesis;

var operator = function operator(monadOperators, polyadOperators) {
  return (0, _regexUtil.patternToRegex)("".concat((0, _utils.sortByLengthDesc)(polyadOperators).map(_regexUtil.escapeRegExp).join('|'), "|") + "[".concat(monadOperators.split('').map(_regexUtil.escapeRegExp).join(''), "]"));
}; // Negative lookahead to avoid matching a keyword that's actually part of identifier,
// which can happen when identifier allows word-boundary characters inside it.
//
// For example "SELECT$ME" should be tokenized as:
// - ["SELECT$ME"] when $ is allowed inside identifiers
// - ["SELECT", "$", "ME"] when $ can't be part of identifiers.


exports.operator = operator;

var rejectIdentCharsPattern = function rejectIdentCharsPattern(_ref) {
  var rest = _ref.rest,
      dashes = _ref.dashes;
  return rest || dashes ? "(?![".concat(rest || '').concat(dashes ? '-' : '', "])") : '';
};
/**
 * Builds a RegExp for all Reserved Keywords in a SQL dialect
 */


var reservedWord = function reservedWord(reservedKeywords) {
  var identChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (reservedKeywords.length === 0) {
    return /^\b$/;
  }

  var avoidIdentChars = rejectIdentCharsPattern(identChars);
  var reservedKeywordsPattern = (0, _utils.sortByLengthDesc)(reservedKeywords).map(_regexUtil.toCaseInsensitivePattern).join('|').replace(/ /g, '\\s+');
  return new RegExp("(?:".concat(reservedKeywordsPattern, ")").concat(avoidIdentChars, "\\b"), 'iuy');
};
/**
 * Builds a RegExp for parameter placeholder patterns
 * @param {string[]} paramTypes - list of strings that denote placeholder types
 * @param {string} pattern - string that denotes placeholder pattern
 */


exports.reservedWord = reservedWord;

var parameter = function parameter(paramTypes, pattern) {
  if (!paramTypes.length) {
    return undefined;
  }

  var typesRegex = paramTypes.map(_regexUtil.escapeRegExp).join('|');
  return (0, _regexUtil.patternToRegex)("(?:".concat(typesRegex, ")(?:").concat(pattern, ")"));
}; // This enables the following quote styles:
// 1. backtick quoted using `` to escape
// 2. square bracket quoted (SQL Server) using ]] to escape
// 3. double quoted using "" or \" to escape
// 4. single quoted using '' or \' to escape
// 5. PostgreSQL dollar-quoted
// 6. BigQuery '''triple-quoted'''
// 7. BigQuery """triple-quoted"""
// 8. Hive and Spark variables: ${name}


exports.parameter = parameter;
var quotePatterns = {
  '``': '(?:`[^`]*(?:$|`))+',
  '[]': '(?:\\[[^\\]]*(?:$|\\]))(?:\\][^\\]]*(?:$|\\]))*',
  '""': '(?:"[^"\\\\]*(?:\\\\.[^"\\\\]*)*(?:"|$))+',
  "''": "(?:'[^'\\\\]*(?:\\\\.[^'\\\\]*)*(?:'|$))+",
  '$$': '(?<tag>\\$\\w*\\$)[\\s\\S]*?(?:\\k<tag>|$)',
  "'''..'''": "'''[^\\\\]*?(?:\\\\.[^\\\\]*?)*?(?:'''|$)",
  '""".."""': '"""[^\\\\]*?(?:\\\\.[^\\\\]*?)*?(?:"""|$)',
  '{}': '(?:\\{[^\\}]*(?:$|\\}))'
};
exports.quotePatterns = quotePatterns;

var singleQuotePattern = function singleQuotePattern(quoteTypes) {
  if (typeof quoteTypes === 'string') {
    return quotePatterns[quoteTypes];
  } else {
    return (0, _regexUtil.prefixesPattern)(quoteTypes) + quotePatterns[quoteTypes.quote];
  }
};
/** Builds a RegExp for matching variables */


var variable = function variable(varTypes) {
  return (0, _regexUtil.patternToRegex)(varTypes.map(function (varType) {
    return 'regex' in varType ? varType.regex : singleQuotePattern(varType);
  }).join('|'));
};
/** Builds a quote-delimited pattern for matching all given quote types */


exports.variable = variable;

var stringPattern = function stringPattern(quoteTypes) {
  return quoteTypes.map(singleQuotePattern).join('|');
};
/** Builds a RegExp for matching quote-delimited patterns */


exports.stringPattern = stringPattern;

var string = function string(quoteTypes) {
  return (0, _regexUtil.patternToRegex)(stringPattern(quoteTypes));
};
/**
 * Builds a RegExp for valid identifiers in a SQL dialect
 */


exports.string = string;

var identifier = function identifier() {
  var specialChars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (0, _regexUtil.patternToRegex)(identifierPattern(specialChars));
};
/**
 * Builds a RegExp string for valid identifiers in a SQL dialect
 */


exports.identifier = identifier;

var identifierPattern = function identifierPattern() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      first = _ref2.first,
      rest = _ref2.rest,
      dashes = _ref2.dashes;

  // Unicode letters, diacritical marks and underscore
  var letter = '\\p{Alphabetic}\\p{Mark}_'; // Numbers 0..9, plus various unicode numbers

  var number = '\\p{Decimal_Number}';
  var firstChars = (0, _regexUtil.escapeRegExp)(first !== null && first !== void 0 ? first : '');
  var restChars = (0, _regexUtil.escapeRegExp)(rest !== null && rest !== void 0 ? rest : '');
  var pattern = "[".concat(letter).concat(firstChars, "][").concat(letter).concat(number).concat(restChars, "]*");
  return dashes ? (0, _regexUtil.withDashes)(pattern) : pattern;
};

exports.identifierPattern = identifierPattern;
//# sourceMappingURL=regexFactory.js.map